const std = @import("std");

const vk = @cImport({
    @cInclude("vulkan/vulkan_core.h");
});

pub const VulkanError = error{
    NotReady,
    Timeout,
    EventSet,
    EventReset,
    Incomplete,
    OutOfHostMemory,
    OutOfDeviceMemory,
    InitializationFailed,
    DeviceLost,
    MemoryMapFailed,
    LayerNotPresent,
    ExtensionNotPresent,
    FeatureNotPresent,
    IncompatibleDriver,
    TooManyObjects,
    FormatNotSupported,
    FragmentedPool,
    Unknown,
    OutOfPoolMemory,
    InvalidExternalHandle,
    Fragmentation,
    InvalidOpaqueCaptureAddress,
    PipelineCompileRequired,
    NotPermitted,
    SurfaceLost,
    NativeWindowInUse,
    Suboptimal,
    OutOfDate,
    IncompatibleDisplay,
    ValidationFailed,
    InvalidShader,
    ImageUsageNotSupported,
    VideoPictureLayoutNotSupported,
    VideoProfileOperationNotSupported,
    VideoProfileFormatNotSupported,
    VideoProfileCodecNotSupported,
    VideoStdVersionNotSupported,
    InvalidDrmFormatModifierPlaneLayout,
    FullScreenExclusiveModeLost,
    ThreadIdle,
    ThreadDone,
    OperationDeferred,
    OperationNotDeferred,
    InvalidVideoStdParameters,
    CompressionExhausted,
    IncompatibleShaderBinary,
    PipelineBinaryMissing,
    NotEnoughSpace,
};

pub fn translateVkError(status: vk.VkResult) VulkanError!void {
    return switch (status) {
        vk.VK_SUCCESS => {},

        vk.VK_NOT_READY => VulkanError.NotReady,
        vk.VK_TIMEOUT => VulkanError.Timeout,
        vk.VK_EVENT_SET => VulkanError.EventSet,
        vk.VK_EVENT_RESET => VulkanError.EventReset,
        vk.VK_INCOMPLETE => VulkanError.Incomplete,
        vk.VK_ERROR_OUT_OF_HOST_MEMORY => VulkanError.OutOfHostMemory,
        vk.VK_ERROR_OUT_OF_DEVICE_MEMORY => VulkanError.OutOfDeviceMemory,
        vk.VK_ERROR_INITIALIZATION_FAILED => VulkanError.InitializationFailed,
        vk.VK_ERROR_DEVICE_LOST => VulkanError.DeviceLost,
        vk.VK_ERROR_MEMORY_MAP_FAILED => VulkanError.MemoryMapFailed,
        vk.VK_ERROR_LAYER_NOT_PRESENT => VulkanError.LayerNotPresent,
        vk.VK_ERROR_EXTENSION_NOT_PRESENT => VulkanError.ExtensionNotPresent,
        vk.VK_ERROR_FEATURE_NOT_PRESENT => VulkanError.FeatureNotPresent,
        vk.VK_ERROR_INCOMPATIBLE_DRIVER => VulkanError.IncompatibleDriver,
        vk.VK_ERROR_TOO_MANY_OBJECTS => VulkanError.TooManyObjects,
        vk.VK_ERROR_FORMAT_NOT_SUPPORTED => VulkanError.FormatNotSupported,
        vk.VK_ERROR_FRAGMENTED_POOL => VulkanError.FragmentedPool,
        vk.VK_ERROR_UNKNOWN => VulkanError.Unknown,
        vk.VK_ERROR_OUT_OF_POOL_MEMORY => VulkanError.OutOfPoolMemory,
        vk.VK_ERROR_INVALID_EXTERNAL_HANDLE => VulkanError.InvalidExternalHandle,
        vk.VK_ERROR_FRAGMENTATION => VulkanError.Fragmentation,
        vk.VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS => VulkanError.InvalidOpaqueCaptureAddress,
        vk.VK_PIPELINE_COMPILE_REQUIRED => VulkanError.PipelineCompileRequired,
        vk.VK_ERROR_NOT_PERMITTED => VulkanError.NotPermitted,
        vk.VK_ERROR_SURFACE_LOST_KHR => VulkanError.SurfaceLost,
        vk.VK_ERROR_NATIVE_WINDOW_IN_USE_KHR => VulkanError.NativeWindowInUse,
        vk.VK_SUBOPTIMAL_KHR => VulkanError.Suboptimal,
        vk.VK_ERROR_OUT_OF_DATE_KHR => VulkanError.OutOfDate,
        vk.VK_ERROR_INCOMPATIBLE_DISPLAY_KHR => VulkanError.IncompatibleDisplay,
        vk.VK_ERROR_VALIDATION_FAILED_EXT => VulkanError.ValidationFailed,
        vk.VK_ERROR_INVALID_SHADER_NV => VulkanError.InvalidShader,
        vk.VK_ERROR_IMAGE_USAGE_NOT_SUPPORTED_KHR => VulkanError.ImageUsageNotSupported,
        vk.VK_ERROR_VIDEO_PICTURE_LAYOUT_NOT_SUPPORTED_KHR => VulkanError.VideoPictureLayoutNotSupported,
        vk.VK_ERROR_VIDEO_PROFILE_OPERATION_NOT_SUPPORTED_KHR => VulkanError.VideoProfileOperationNotSupported,
        vk.VK_ERROR_VIDEO_PROFILE_FORMAT_NOT_SUPPORTED_KHR => VulkanError.VideoProfileFormatNotSupported,
        vk.VK_ERROR_VIDEO_PROFILE_CODEC_NOT_SUPPORTED_KHR => VulkanError.VideoProfileCodecNotSupported,
        vk.VK_ERROR_VIDEO_STD_VERSION_NOT_SUPPORTED_KHR => VulkanError.VideoStdVersionNotSupported,
        vk.VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT => VulkanError.InvalidDrmFormatModifierPlaneLayout,
        vk.VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT => VulkanError.FullScreenExclusiveModeLost,
        vk.VK_THREAD_IDLE_KHR => VulkanError.ThreadIdle,
        vk.VK_THREAD_DONE_KHR => VulkanError.ThreadDone,
        vk.VK_OPERATION_DEFERRED_KHR => VulkanError.OperationDeferred,
        vk.VK_OPERATION_NOT_DEFERRED_KHR => VulkanError.OperationNotDeferred,
        vk.VK_ERROR_INVALID_VIDEO_STD_PARAMETERS_KHR => VulkanError.InvalidVideoStdParameters,
        vk.VK_ERROR_COMPRESSION_EXHAUSTED_EXT => VulkanError.CompressionExhausted,
        vk.VK_INCOMPATIBLE_SHADER_BINARY_EXT => VulkanError.IncompatibleShaderBinary,
        vk.VK_PIPELINE_BINARY_MISSING_KHR => VulkanError.PipelineBinaryMissing,
        vk.VK_ERROR_NOT_ENOUGH_SPACE_KHR => VulkanError.NotEnoughSpace,

        else => VulkanError.Unknown,
    };
}

pub fn isWayland(allocator: std.mem.Allocator) !bool {
    const xdgSessionType = try std.process.getEnvVarOwned(allocator, "XDG_SESSION_TYPE");
    return std.mem.eql(u8, xdgSessionType, "wayland");
}
